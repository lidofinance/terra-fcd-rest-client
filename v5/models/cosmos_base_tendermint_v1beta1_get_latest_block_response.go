// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CosmosBaseTendermintV1beta1GetLatestBlockResponse GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.
//
// swagger:model cosmos.base.tendermint.v1beta1.GetLatestBlockResponse
type CosmosBaseTendermintV1beta1GetLatestBlockResponse struct {

	// block
	Block *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock `json:"block,omitempty"`

	// block id
	BlockID *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID `json:"block_id,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponse) validateBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.Block) { // not required
		return nil
	}

	if m.Block != nil {
		if err := m.Block.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponse) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponse) contextValidateBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.Block != nil {
		if err := m.Block.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponse) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {
		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponse) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock cosmos base tendermint v1beta1 get latest block response block
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock struct {

	// data
	Data *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockData `json:"data,omitempty"`

	// evidence
	Evidence *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence `json:"evidence,omitempty"`

	// header
	Header *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader `json:"header,omitempty"`

	// last commit
	LastCommit *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit `json:"last_commit,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastCommit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) validateData(formats strfmt.Registry) error {
	if swag.IsZero(m.Data) { // not required
		return nil
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "data")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	if m.Evidence != nil {
		if err := m.Evidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) validateLastCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.LastCommit) { // not required
		return nil
	}

	if m.LastCommit != nil {
		if err := m.LastCommit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	if m.Data != nil {
		if err := m.Data.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "data")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.Evidence != nil {
		if err := m.Evidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {
		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) contextValidateLastCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.LastCommit != nil {
		if err := m.LastCommit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockData Data contains the set of transactions included in the block
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockData
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockData struct {

	// Txs that will be applied by state @ block.Height+1.
	// NOTE: not all txs here are valid.  We're just agreeing on the order first.
	// This means that block.AppHash does not include these txs.
	Txs []strfmt.Base64 `json:"txs"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block data
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockData) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block data based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockData) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence cosmos base tendermint v1beta1 get latest block response block evidence
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence struct {

	// evidence
	Evidence []*CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0 `json:"evidence"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	for i := 0; i < len(m.Evidence); i++ {
		if swag.IsZero(m.Evidence[i]) { // not required
			continue
		}

		if m.Evidence[i] != nil {
			if err := m.Evidence[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Evidence); i++ {

		if m.Evidence[i] != nil {
			if err := m.Evidence[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0 cosmos base tendermint v1beta1 get latest block response block evidence evidence items0
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0 struct {

	// duplicate vote evidence
	DuplicateVoteEvidence *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence `json:"duplicate_vote_evidence,omitempty"`

	// light client attack evidence
	LightClientAttackEvidence *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence `json:"light_client_attack_evidence,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuplicateVoteEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLightClientAttackEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0) validateDuplicateVoteEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.DuplicateVoteEvidence) { // not required
		return nil
	}

	if m.DuplicateVoteEvidence != nil {
		if err := m.DuplicateVoteEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0) validateLightClientAttackEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.LightClientAttackEvidence) { // not required
		return nil
	}

	if m.LightClientAttackEvidence != nil {
		if err := m.LightClientAttackEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuplicateVoteEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLightClientAttackEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0) contextValidateDuplicateVoteEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.DuplicateVoteEvidence != nil {
		if err := m.DuplicateVoteEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0) contextValidateLightClientAttackEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.LightClientAttackEvidence != nil {
		if err := m.LightClientAttackEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence struct {

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validator power
	ValidatorPower string `json:"validator_power,omitempty"`

	// vote a
	Votea *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea `json:"vote_a,omitempty"`

	// vote b
	Voteb *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb `json:"vote_b,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVotea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVoteb(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVotea(formats strfmt.Registry) error {
	if swag.IsZero(m.Votea) { // not required
		return nil
	}

	if m.Votea != nil {
		if err := m.Votea.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVoteb(formats strfmt.Registry) error {
	if swag.IsZero(m.Voteb) { // not required
		return nil
	}

	if m.Voteb != nil {
		if err := m.Voteb.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVotea(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVoteb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVotea(ctx context.Context, formats strfmt.Registry) error {

	if m.Votea != nil {
		if err := m.Votea.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVoteb(ctx context.Context, formats strfmt.Registry) error {

	if m.Voteb != nil {
		if err := m.Voteb.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea Vote represents a prevote, precommit, or commit vote from validators for
// consensus.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea struct {

	// block id
	BlockID *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// SignedMsgType is a type of signed message in the consensus.
	//
	//  - SIGNED_MSG_TYPE_PREVOTE: Votes
	//  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
	// Enum: [SIGNED_MSG_TYPE_UNKNOWN SIGNED_MSG_TYPE_PREVOTE SIGNED_MSG_TYPE_PRECOMMIT SIGNED_MSG_TYPE_PROPOSAL]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence votea
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_a"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum = append(cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, v)
	}
}

const (

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_a"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence votea based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {
		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID BlockID
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence votea block ID
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence votea block ID based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader PartsetHeader
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence votea block ID part set header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence votea block ID part set header based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb Vote represents a prevote, precommit, or commit vote from validators for
// consensus.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb struct {

	// block id
	BlockID *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// SignedMsgType is a type of signed message in the consensus.
	//
	//  - SIGNED_MSG_TYPE_PREVOTE: Votes
	//  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
	// Enum: [SIGNED_MSG_TYPE_UNKNOWN SIGNED_MSG_TYPE_PREVOTE SIGNED_MSG_TYPE_PRECOMMIT SIGNED_MSG_TYPE_PROPOSAL]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence voteb
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_b"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum = append(cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, v)
	}
}

const (

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_b"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence voteb based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {
		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID BlockID
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence voteb block ID
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence voteb block ID based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader PartsetHeader
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence voteb block ID part set header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 duplicate vote evidence voteb block ID part set header based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence struct {

	// byzantine validators
	ByzantineValidators []*CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 `json:"byzantine_validators"`

	// common height
	CommonHeight string `json:"common_height,omitempty"`

	// conflicting block
	ConflictingBlock *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock `json:"conflicting_block,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateByzantineValidators(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConflictingBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateByzantineValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.ByzantineValidators) { // not required
		return nil
	}

	for i := 0; i < len(m.ByzantineValidators); i++ {
		if swag.IsZero(m.ByzantineValidators[i]) { // not required
			continue
		}

		if m.ByzantineValidators[i] != nil {
			if err := m.ByzantineValidators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateConflictingBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.ConflictingBlock) { // not required
		return nil
	}

	if m.ConflictingBlock != nil {
		if err := m.ConflictingBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateByzantineValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConflictingBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateByzantineValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ByzantineValidators); i++ {

		if m.ByzantineValidators[i] != nil {
			if err := m.ByzantineValidators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateConflictingBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.ConflictingBlock != nil {
		if err := m.ConflictingBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence byzantine validators items0
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence byzantine validators items0
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence byzantine validators items0 based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {
		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey PublicKey defines the keys available for use with Tendermint Validators
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence byzantine validators items0 pub key
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence byzantine validators items0 pub key based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock struct {

	// signed header
	SignedHeader *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader `json:"signed_header,omitempty"`

	// validator set
	ValidatorSet *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet `json:"validator_set,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSignedHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidatorSet(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateSignedHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.SignedHeader) { // not required
		return nil
	}

	if m.SignedHeader != nil {
		if err := m.SignedHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateValidatorSet(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidatorSet) { // not required
		return nil
	}

	if m.ValidatorSet != nil {
		if err := m.ValidatorSet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSignedHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidatorSet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateSignedHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.SignedHeader != nil {
		if err := m.SignedHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateValidatorSet(ctx context.Context, formats strfmt.Registry) error {

	if m.ValidatorSet != nil {
		if err := m.ValidatorSet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader struct {

	// commit
	Commit *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit `json:"commit,omitempty"`

	// header
	Header *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader `json:"header,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.Commit) { // not required
		return nil
	}

	if m.Commit != nil {
		if err := m.Commit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.Commit != nil {
		if err := m.Commit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {
		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit Commit contains the evidence that a block was committed by a set of validators.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit struct {

	// block id
	BlockID *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header commit
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header commit based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {
		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID BlockID
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader PartsetHeader
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 CommitSig is a part of the Vote included in a Commit.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 struct {

	// BlockIdFlag indicates which BlcokID the signature is for
	// Enum: [BLOCK_ID_FLAG_UNKNOWN BLOCK_ID_FLAG_ABSENT BLOCK_ID_FLAG_COMMIT BLOCK_ID_FLAG_NIL]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0 based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader Header defines the structure of a Tendermint block header.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// consensus info
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID `json:"last_block_id,omitempty"`

	// hashes of block data
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// hashes from the app output from the prev block
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion `json:"version,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"conflicting_block"+"."+"signed_header"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header header based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {
		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID BlockID
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader PartsetHeader
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion basic block info
//
// Consensus captures the consensus rules for processing a block in the blockchain,
// including all blockchain data structures and the rules of the application's
// state transition machine.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header header version
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block signed header header version based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet struct {

	// proposer
	Proposer *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer `json:"proposer,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validators
	Validators []*CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 `json:"validators"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProposer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidators(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateProposer(formats strfmt.Registry) error {
	if swag.IsZero(m.Proposer) { // not required
		return nil
	}

	if m.Proposer != nil {
		if err := m.Proposer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.Validators) { // not required
		return nil
	}

	for i := 0; i < len(m.Validators); i++ {
		if swag.IsZero(m.Validators[i]) { // not required
			continue
		}

		if m.Validators[i] != nil {
			if err := m.Validators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProposer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateProposer(ctx context.Context, formats strfmt.Registry) error {

	if m.Proposer != nil {
		if err := m.Proposer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Validators); i++ {

		if m.Validators[i] != nil {
			if err := m.Validators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set proposer
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set proposer
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set proposer based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {
		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey PublicKey defines the keys available for use with Tendermint Validators
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {
		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey PublicKey defines the keys available for use with Tendermint Validators
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader Header defines the structure of a Tendermint block header.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// consensus info
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID `json:"last_block_id,omitempty"`

	// hashes of block data
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// hashes from the app output from the prev block
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderVersion `json:"version,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("block"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block header based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {
		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID BlockID
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block header last block ID
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block header last block ID based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockIDPartSetHeader PartsetHeader
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockIDPartSetHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block header last block ID part set header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block header last block ID part set header based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderVersion basic block info
//
// Consensus captures the consensus rules for processing a block in the blockchain,
// including all blockchain data structures and the rules of the application's
// state transition machine.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderVersion
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block header version
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block header version based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderVersion) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID BlockID
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block ID
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block ID based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockIDPartSetHeader PartsetHeader
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockIDPartSetHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block ID part set header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block ID part set header based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit Commit contains the evidence that a block was committed by a set of validators.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit struct {

	// block id
	BlockID *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block last commit
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block last commit based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {
		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID BlockID
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block last commit block ID
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos base tendermint v1beta1 get latest block response block last commit block ID based on the context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockIDPartSetHeader PartsetHeader
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockIDPartSetHeader
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block last commit block ID part set header
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block last commit block ID part set header based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0 CommitSig is a part of the Vote included in a Commit.
//
// swagger:model CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0
type CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0 struct {

	// BlockIdFlag indicates which BlcokID the signature is for
	// Enum: [BLOCK_ID_FLAG_UNKNOWN BLOCK_ID_FLAG_ABSENT BLOCK_ID_FLAG_COMMIT BLOCK_ID_FLAG_NIL]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this cosmos base tendermint v1beta1 get latest block response block last commit signatures items0
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cosmos base tendermint v1beta1 get latest block response block last commit signatures items0 based on context it is used
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBaseTendermintV1beta1GetLatestBlockResponseBlockLastCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
