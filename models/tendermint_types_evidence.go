// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TendermintTypesEvidence tendermint types evidence
//
// swagger:model tendermint.types.Evidence
type TendermintTypesEvidence struct {

	// duplicate vote evidence
	DuplicateVoteEvidence *TendermintTypesEvidenceDuplicateVoteEvidence `json:"duplicate_vote_evidence,omitempty"`

	// light client attack evidence
	LightClientAttackEvidence *TendermintTypesEvidenceLightClientAttackEvidence `json:"light_client_attack_evidence,omitempty"`
}

// Validate validates this tendermint types evidence
func (m *TendermintTypesEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuplicateVoteEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLightClientAttackEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidence) validateDuplicateVoteEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.DuplicateVoteEvidence) { // not required
		return nil
	}

	if m.DuplicateVoteEvidence != nil {
		if err := m.DuplicateVoteEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidence) validateLightClientAttackEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.LightClientAttackEvidence) { // not required
		return nil
	}

	if m.LightClientAttackEvidence != nil {
		if err := m.LightClientAttackEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence based on the context it is used
func (m *TendermintTypesEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuplicateVoteEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLightClientAttackEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidence) contextValidateDuplicateVoteEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.DuplicateVoteEvidence != nil {
		if err := m.DuplicateVoteEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidence) contextValidateLightClientAttackEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.LightClientAttackEvidence != nil {
		if err := m.LightClientAttackEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidence) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceDuplicateVoteEvidence DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.
//
// swagger:model TendermintTypesEvidenceDuplicateVoteEvidence
type TendermintTypesEvidenceDuplicateVoteEvidence struct {

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validator power
	ValidatorPower string `json:"validator_power,omitempty"`

	// vote a
	Votea *TendermintTypesEvidenceDuplicateVoteEvidenceVotea `json:"vote_a,omitempty"`

	// vote b
	Voteb *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb `json:"vote_b,omitempty"`
}

// Validate validates this tendermint types evidence duplicate vote evidence
func (m *TendermintTypesEvidenceDuplicateVoteEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVotea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVoteb(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidence) validateVotea(formats strfmt.Registry) error {
	if swag.IsZero(m.Votea) { // not required
		return nil
	}

	if m.Votea != nil {
		if err := m.Votea.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidence) validateVoteb(formats strfmt.Registry) error {
	if swag.IsZero(m.Voteb) { // not required
		return nil
	}

	if m.Voteb != nil {
		if err := m.Voteb.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence duplicate vote evidence based on the context it is used
func (m *TendermintTypesEvidenceDuplicateVoteEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVotea(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVoteb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidence) contextValidateVotea(ctx context.Context, formats strfmt.Registry) error {

	if m.Votea != nil {
		if err := m.Votea.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidence) contextValidateVoteb(ctx context.Context, formats strfmt.Registry) error {

	if m.Voteb != nil {
		if err := m.Voteb.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidence) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceDuplicateVoteEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceDuplicateVoteEvidenceVotea Vote represents a prevote, precommit, or commit vote from validators for
// consensus.
//
// swagger:model TendermintTypesEvidenceDuplicateVoteEvidenceVotea
type TendermintTypesEvidenceDuplicateVoteEvidenceVotea struct {

	// block id
	BlockID *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// SignedMsgType is a type of signed message in the consensus.
	//
	//  - SIGNED_MSG_TYPE_PREVOTE: Votes
	//  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
	// Enum: [SIGNED_MSG_TYPE_UNKNOWN SIGNED_MSG_TYPE_PREVOTE SIGNED_MSG_TYPE_PRECOMMIT SIGNED_MSG_TYPE_PROPOSAL]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this tendermint types evidence duplicate vote evidence votea
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotea) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotea) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotea) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_a"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var tendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeTypePropEnum = append(tendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeTypePropEnum, v)
	}
}

const (

	// TendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	TendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// TendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	TendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// TendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	TendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// TendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	TendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotea) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, tendermintTypesEvidenceDuplicateVoteEvidenceVoteaTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotea) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_a"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this tendermint types evidence duplicate vote evidence votea based on the context it is used
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotea) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotea) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {
		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotea) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotea) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceDuplicateVoteEvidenceVotea
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID BlockID
//
// swagger:model TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID
type TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this tendermint types evidence duplicate vote evidence votea block ID
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence duplicate vote evidence votea block ID based on the context it is used
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockIDPartSetHeader PartsetHeader
//
// swagger:model TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockIDPartSetHeader
type TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this tendermint types evidence duplicate vote evidence votea block ID part set header
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this tendermint types evidence duplicate vote evidence votea block ID part set header based on context it is used
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceDuplicateVoteEvidenceVoteaBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceDuplicateVoteEvidenceVoteb Vote represents a prevote, precommit, or commit vote from validators for
// consensus.
//
// swagger:model TendermintTypesEvidenceDuplicateVoteEvidenceVoteb
type TendermintTypesEvidenceDuplicateVoteEvidenceVoteb struct {

	// block id
	BlockID *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// SignedMsgType is a type of signed message in the consensus.
	//
	//  - SIGNED_MSG_TYPE_PREVOTE: Votes
	//  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
	// Enum: [SIGNED_MSG_TYPE_UNKNOWN SIGNED_MSG_TYPE_PREVOTE SIGNED_MSG_TYPE_PRECOMMIT SIGNED_MSG_TYPE_PROPOSAL]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this tendermint types evidence duplicate vote evidence voteb
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_b"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var tendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeTypePropEnum = append(tendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeTypePropEnum, v)
	}
}

const (

	// TendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	TendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// TendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	TendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// TendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	TendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// TendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	TendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, tendermintTypesEvidenceDuplicateVoteEvidenceVotebTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_b"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this tendermint types evidence duplicate vote evidence voteb based on the context it is used
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {
		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVoteb) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceDuplicateVoteEvidenceVoteb
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID BlockID
//
// swagger:model TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID
type TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this tendermint types evidence duplicate vote evidence voteb block ID
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence duplicate vote evidence voteb block ID based on the context it is used
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockIDPartSetHeader PartsetHeader
//
// swagger:model TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockIDPartSetHeader
type TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this tendermint types evidence duplicate vote evidence voteb block ID part set header
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this tendermint types evidence duplicate vote evidence voteb block ID part set header based on context it is used
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceDuplicateVoteEvidenceVotebBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidence LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidence
type TendermintTypesEvidenceLightClientAttackEvidence struct {

	// byzantine validators
	ByzantineValidators []*TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0 `json:"byzantine_validators"`

	// common height
	CommonHeight string `json:"common_height,omitempty"`

	// conflicting block
	ConflictingBlock *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock `json:"conflicting_block,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence
func (m *TendermintTypesEvidenceLightClientAttackEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateByzantineValidators(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConflictingBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidence) validateByzantineValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.ByzantineValidators) { // not required
		return nil
	}

	for i := 0; i < len(m.ByzantineValidators); i++ {
		if swag.IsZero(m.ByzantineValidators[i]) { // not required
			continue
		}

		if m.ByzantineValidators[i] != nil {
			if err := m.ByzantineValidators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidence) validateConflictingBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.ConflictingBlock) { // not required
		return nil
	}

	if m.ConflictingBlock != nil {
		if err := m.ConflictingBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateByzantineValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConflictingBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidence) contextValidateByzantineValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ByzantineValidators); i++ {

		if m.ByzantineValidators[i] != nil {
			if err := m.ByzantineValidators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidence) contextValidateConflictingBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.ConflictingBlock != nil {
		if err := m.ConflictingBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidence) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0 tendermint types evidence light client attack evidence byzantine validators items0
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0
type TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence byzantine validators items0
func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence byzantine validators items0 based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {
		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0PubKey PublicKey defines the keys available for use with Tendermint Validators
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0PubKey
type TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence byzantine validators items0 pub key
func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this tendermint types evidence light client attack evidence byzantine validators items0 pub key based on context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceByzantineValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock tendermint types evidence light client attack evidence conflicting block
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock struct {

	// signed header
	SignedHeader *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader `json:"signed_header,omitempty"`

	// validator set
	ValidatorSet *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet `json:"validator_set,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSignedHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidatorSet(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock) validateSignedHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.SignedHeader) { // not required
		return nil
	}

	if m.SignedHeader != nil {
		if err := m.SignedHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock) validateValidatorSet(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidatorSet) { // not required
		return nil
	}

	if m.ValidatorSet != nil {
		if err := m.ValidatorSet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence conflicting block based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSignedHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidatorSet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock) contextValidateSignedHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.SignedHeader != nil {
		if err := m.SignedHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock) contextValidateValidatorSet(ctx context.Context, formats strfmt.Registry) error {

	if m.ValidatorSet != nil {
		if err := m.ValidatorSet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader tendermint types evidence light client attack evidence conflicting block signed header
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader struct {

	// commit
	Commit *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit `json:"commit,omitempty"`

	// header
	Header *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader `json:"header,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block signed header
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader) validateCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.Commit) { // not required
		return nil
	}

	if m.Commit != nil {
		if err := m.Commit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence conflicting block signed header based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.Commit != nil {
		if err := m.Commit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {
		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit Commit contains the evidence that a block was committed by a set of validators.
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit struct {

	// block id
	BlockID *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block signed header commit
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence conflicting block signed header commit based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {
		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID BlockID
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block signed header commit block ID
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence conflicting block signed header commit block ID based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader PartsetHeader
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block signed header commit block ID part set header
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this tendermint types evidence light client attack evidence conflicting block signed header commit block ID part set header based on context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 CommitSig is a part of the Vote included in a Commit.
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 struct {

	// BlockIdFlag indicates which BlcokID the signature is for
	// Enum: [BLOCK_ID_FLAG_UNKNOWN BLOCK_ID_FLAG_ABSENT BLOCK_ID_FLAG_COMMIT BLOCK_ID_FLAG_NIL]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block signed header commit signatures items0
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var tendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		tendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(tendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, tendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this tendermint types evidence light client attack evidence conflicting block signed header commit signatures items0 based on context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader Header defines the structure of a Tendermint block header.
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// consensus info
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID `json:"last_block_id,omitempty"`

	// hashes of block data
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// hashes from the app output from the prev block
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion `json:"version,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block signed header header
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"conflicting_block"+"."+"signed_header"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence conflicting block signed header header based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {
		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {
		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID BlockID
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block signed header header last block ID
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence conflicting block signed header header last block ID based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader PartsetHeader
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block signed header header last block ID part set header
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this tendermint types evidence light client attack evidence conflicting block signed header header last block ID part set header based on context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion basic block info
//
// Consensus captures the consensus rules for processing a block in the blockchain,
// including all blockchain data structures and the rules of the application's
// state transition machine.
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block signed header header version
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this tendermint types evidence light client attack evidence conflicting block signed header header version based on context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet tendermint types evidence light client attack evidence conflicting block validator set
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet struct {

	// proposer
	Proposer *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer `json:"proposer,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validators
	Validators []*TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 `json:"validators"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block validator set
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProposer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidators(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet) validateProposer(formats strfmt.Registry) error {
	if swag.IsZero(m.Proposer) { // not required
		return nil
	}

	if m.Proposer != nil {
		if err := m.Proposer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet) validateValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.Validators) { // not required
		return nil
	}

	for i := 0; i < len(m.Validators); i++ {
		if swag.IsZero(m.Validators[i]) { // not required
			continue
		}

		if m.Validators[i] != nil {
			if err := m.Validators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence conflicting block validator set based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProposer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateProposer(ctx context.Context, formats strfmt.Registry) error {

	if m.Proposer != nil {
		if err := m.Proposer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Validators); i++ {

		if m.Validators[i] != nil {
			if err := m.Validators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSet
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer tendermint types evidence light client attack evidence conflicting block validator set proposer
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block validator set proposer
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence conflicting block validator set proposer based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {
		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey PublicKey defines the keys available for use with Tendermint Validators
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block validator set proposer pub key
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this tendermint types evidence light client attack evidence conflicting block validator set proposer pub key based on context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 tendermint types evidence light client attack evidence conflicting block validator set validators items0
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block validator set validators items0
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this tendermint types evidence light client attack evidence conflicting block validator set validators items0 based on the context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {
		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey PublicKey defines the keys available for use with Tendermint Validators
//
// swagger:model TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
type TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this tendermint types evidence light client attack evidence conflicting block validator set validators items0 pub key
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this tendermint types evidence light client attack evidence conflicting block validator set validators items0 pub key based on context it is used
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res TendermintTypesEvidenceLightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
